diff -r 1194/src/config/CVS/Tag 1195/src/config/CVS/Tag
1c1
< D2006.09.18.05.09.59
---
> D2006.09.18.18.04.29
diff -r 1194/src/CVS/Entries 1195/src/CVS/Entries
38a39
> /jsarray.c/3.96/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
56a58,59
> /jsemit.c/3.213/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
> /jsemit.h/3.67/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
58a62
> /jsfun.c/3.164/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
63a68
> /jsinterp.c/3.291/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
76a82
> /jsobj.c/3.287/Result of merge//D2006.09.18.18.04.29
77a84,86
> /jsopcode.c/3.184/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
> /jsopcode.h/3.37/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
> /jsopcode.tbl/3.78/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
78a88,89
> /jsparse.c/3.246/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
> /jsparse.h/3.39/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
85a97
> /jsscan.c/3.113/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
88a101
> /jsscript.c/3.112/Mon Nov 17 05:02:47 2014//D2006.09.18.18.04.29
105,117d117
< /jsarray.c/3.95/Mon Nov 17 05:02:48 2014//D2006.09.18.05.09.59
< /jsemit.c/3.212/Mon Nov 17 05:02:48 2014//D2006.09.18.05.09.59
< /jsemit.h/3.66/Mon Nov 17 05:02:48 2014//D2006.09.18.05.09.59
< /jsfun.c/3.163/Mon Nov 17 05:02:48 2014//D2006.09.18.05.09.59
< /jsinterp.c/3.290/Mon Nov 17 05:02:48 2014//D2006.09.18.05.09.59
< /jsobj.c/3.286/Result of merge//D2006.09.18.05.09.59
< /jsopcode.c/3.183/Mon Nov 17 05:02:49 2014//D2006.09.18.05.09.59
< /jsopcode.h/3.36/Mon Nov 17 05:02:49 2014//D2006.09.18.05.09.59
< /jsopcode.tbl/3.77/Mon Nov 17 05:02:49 2014//D2006.09.18.05.09.59
< /jsparse.c/3.245/Mon Nov 17 05:02:49 2014//D2006.09.18.05.09.59
< /jsparse.h/3.38/Mon Nov 17 05:02:49 2014//D2006.09.18.05.09.59
< /jsscan.c/3.112/Mon Nov 17 05:02:49 2014//D2006.09.18.05.09.59
< /jsscript.c/3.111/Mon Nov 17 05:02:49 2014//D2006.09.18.05.09.59
diff -r 1194/src/CVS/Tag 1195/src/CVS/Tag
1c1
< D2006.09.18.05.09.59
---
> D2006.09.18.18.04.29
diff -r 1194/src/editline/CVS/Tag 1195/src/editline/CVS/Tag
1c1
< D2006.09.18.05.09.59
---
> D2006.09.18.18.04.29
diff -r 1194/src/fdlibm/CVS/Tag 1195/src/fdlibm/CVS/Tag
1c1
< D2006.09.18.05.09.59
---
> D2006.09.18.18.04.29
diff -r 1194/src/jsarray.c 1195/src/jsarray.c
1587c1587
<     callable = js_ValueToCallableObject(cx, &argv[0], 0);
---
>     callable = js_ValueToCallableObject(cx, &argv[0], JSV2F_SEARCH_STACK);
diff -r 1194/src/jsemit.c 1195/src/jsemit.c
1415c1415,1417
<     if (label) {
---
>     if (label)
>         index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
>     else if (noteType != SRC_NULL)
1417,1426c1419,1422
<         if (index < 0)
<             return -1;
<         if (!js_SetSrcNoteOffset(cx, cg, (uintN)index, 0,
<                                  (ptrdiff_t) ALE_INDEX(label))) {
<             return -1;
<         }
<     } else if (noteType != SRC_NULL) {
<         if (js_NewSrcNote(cx, cg, noteType) < 0)
<             return -1;
<     }
---
>     else
>         index = 0;
>     if (index < 0)
>         return -1;
2272,2275c2268,2271
<  * uses of JSOP_GETMETHOD that implicitly qualify the method-property name with
<  * a function:: prefix.  All other JSOP_GETMETHOD and JSOP_SETMETHOD uses must
<  * be explicit, so need a distinct source note (SRC_PCDELTA rather than PCBASE)
<  * for round-tripping through the beloved decompiler.
---
>  * uses of JSOP_GETMETHOD that implicitly qualify the method property's name
>  * with a function:: prefix.  All other JSOP_GETMETHOD and JSOP_SETMETHOD uses
>  * must be explicit, so we need a distinct source note (SRC_METHODBASE rather
>  * than SRC_PCBASE) for round-tripping through the beloved decompiler.
2285c2281
<            ? SRC_PCDELTA
---
>            ? SRC_METHODBASE
2845a2842,2843
>                 uintN noteCount, noteCountDelta;
> 
2846a2845
>                 noteCount = CG_NOTE_COUNT(cg);
2850a2850,2852
>                 noteCountDelta = CG_NOTE_COUNT(cg) - noteCount;
>                 if (noteCountDelta != 0)
>                     caseNoteIndex += noteCountDelta;
3333c3335,3336
<         if (pn2->pn_type == TOK_COMMA) {
---
>         /* Nullary comma node makes a hole in the array destructurer. */
>         if (pn2->pn_type == TOK_COMMA && pn2->pn_arity == PN_NULLARY) {
4209a4213
>             op = JSOP_NOP;
4221,4222d4224
<                     op = JSOP_NOP;
<                     goto destructuring_for;
5286a5289,5292
> #if JS_HAS_DESTRUCTURING
>             pn2->pn_type != TOK_RB &&
>             pn2->pn_type != TOK_RC &&
> #endif
5314c5320
<             if (!EmitDestructuringOps(cx, cg, op, pn2))
---
>             if (!EmitDestructuringOps(cx, cg, JSOP_NOP, pn2))
5790d5795
<         tmp = CG_OFFSET(cg);
5809a5815
>         JS_ASSERT(CG_OFFSET(cg) == top);
5815,5818c5821,5830
<         if (noteIndex >= 0 &&
<             !js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0,
<                                  CG_OFFSET(cg) - tmp)) {
<             return JS_FALSE;
---
>         op = pn->pn_op;
>         if (op == JSOP_LEAVEBLOCKEXPR) {
>             if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
>                 return JS_FALSE;
>         } else {
>             if (noteIndex >= 0 &&
>                 !js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0,
>                                      CG_OFFSET(cg) - top)) {
>                 return JS_FALSE;
>             }
5822c5834
<         EMIT_UINT16_IMM_OP(pn->pn_op, count);
---
>         EMIT_UINT16_IMM_OP(op, count);
6282c6294
<     {"unused21",        0,      0,      0},
---
>     {"extended",       -1,      0,      0},
diff -r 1194/src/jsemit.h 1195/src/jsemit.h
82a83,97
> /*
>  * STMT_TYPE_MAYBE_SCOPE tells whether a statement type is always, or may
>  * become, a lexical scope.  It therefore includes block and switch (the two
>  * "maybe" scopes) and excludes with (which has dynamic scope, pending the
>  * "reformed with" in ES4/JS2).  It includes all try-catch-finally types.
>  *
>  * STMT_TYPE_LINKS_SCOPE tells whether a JSStmtInfo of the given type eagerly
>  * links to other scoping statement info records.  It excludes the two "maybe"
>  * types, block and switch, as well as the try and both finally types, since
>  * try, etc., don't need block scope unless they contain let declarations.
>  *
>  * We treat with as a static scope because it prevents lexical binding from
>  * continuing further up the static scope chain.  With the "reformed with"
>  * proposal for JS2, we'll be able to model it statically, too.
>  */
85a101
> 
87a104
> 
483a501,511
>  *
>  * Note on adding new source notes: every pair of bytecodes (A, B) where A and
>  * B have disjoint sets of source notes that could apply to each bytecode may
>  * reuse the same note type value for two notes (snA, snB) that have the same
>  * arity, offsetBias, and isSpanDep initializers in js_SrcNoteSpec.  This is
>  * why SRC_IF and SRC_INITPROP have the same value below.  For bad historical
>  * reasons, some bytecodes below that could be overlayed have not been, but
>  * before using SRC_EXTENDED, consider compressing the existing note types.
>  *
>  * Don't forget to update JSXDR_BYTECODE_VERSION in jsxdrapi.h for all such
>  * incompatible source note or other bytecode changes.
498,501c526,528
<     SRC_PCDELTA     = 7,        /* distance from comma-operator to next POP,
<                                    or from CONDSWITCH to first CASE opcode --
<                                    or SRC_PCBASE variant for obj.function::foo
<                                    gets and sets */
---
>     SRC_PCDELTA     = 7,        /* distance forward from comma-operator to
>                                    next POP, or from CONDSWITCH to first CASE
>                                    opcode, etc. -- always a forward delta */
507,508c534,539
<     SRC_PCBASE      = 12,       /* distance back from annotated get- or setprop
<                                    op to first obj.prop.subprop bytecode */
---
>     SRC_PCBASE      = 12,       /* distance back from annotated getprop or
>                                    setprop op to left-most obj.prop.subprop
>                                    bytecode -- always a backward delta */
>     SRC_METHODBASE  = 13,       /* SRC_PCBASE variant for obj.function::foo
>                                    gets and sets; disjoint from SRC_LABEL by
>                                    bytecode to which it applies */
518c549
<     SRC_UNUSED21    = 21,       /* unused */
---
>     SRC_EXTENDED    = 21,       /* extended source note, 32-159, in next byte */
diff -r 1194/src/jsfun.c 1195/src/jsfun.c
2237,2238c2237
<     JSType type;
<     JSString *fallback;
---
>     JSStackFrame *fp;
2243,2250c2242,2243
<     /*
<      * We provide the typename as the fallback to handle the case when
<      * valueOf is not a function, which prevents ValueToString from being
<      * called as the default case inside js_DecompileValueGenerator (and
<      * so recursing back to here).
<      */
<     type = JS_TypeOfValue(cx, *vp);
<     fallback = ATOM_TO_STRING(cx->runtime->atomState.typeAtoms[type]);
---
>     for (fp = cx->fp; fp && !fp->spbase; fp = fp->down)
>         continue;
2252c2245,2247
<                                      (flags & JSV2F_SEARCH_STACK)
---
>                                      (fp && fp->spbase <= vp && vp < fp->sp)
>                                      ? vp - fp->sp
>                                      : (flags & JSV2F_SEARCH_STACK)
2254,2255d2248
<                                      : cx->fp
<                                      ? vp - cx->fp->sp
2258c2251
<                                      fallback);
---
>                                      NULL);
diff -r 1194/src/jsinterp.c 1195/src/jsinterp.c
2336,2341c2336,2338
<             /*
<              * N.B. JSOP_SWAP doesn't swap the corresponding generating pcs
<              * for the operands it swaps.
<              */
<             ltmp = sp[-1];
<             sp[-1] = sp[-2];
---
>             vp = sp - depth;    /* swap generating pc's for the decompiler */
>             ltmp = vp[-1];
>             vp[-1] = vp[-2];
2342a2340,2342
>             rtmp = sp[-1];
>             sp[-1] = sp[-2];
>             sp[-2] = rtmp;
2944,2945c2944,2948
<             rval = sp[-1];
<             PUSH_OPND(rval);
---
>             vp = sp - 1;                /* address top of stack */
>             rval = *vp;
>             vp -= depth;                /* address generating pc */
>             vp[1] = *vp;
>             PUSH(rval);
2949,2953c2952,2959
<             JS_ASSERT(sp - 1 > fp->spbase);
<             lval = FETCH_OPND(-2);
<             rval = FETCH_OPND(-1);
<             PUSH_OPND(lval);
<             PUSH_OPND(rval);
---
>             JS_ASSERT(sp - 2 >= fp->spbase);
>             vp = sp - 1;                /* address top of stack */
>             lval = vp[-1];
>             rval = *vp;
>             vp -= depth;                /* address generating pc */
>             vp[1] = vp[2] = *vp;
>             PUSH(lval);
>             PUSH(rval);
3292a3299
>             pc2 = (jsbytecode *) sp[-2-depth];
3299a3307
>             sp[-depth] = (jsval)pc2;
3303a3312
>             pc2 = (jsbytecode *) sp[-2-depth];
3310a3320
>             sp[-depth] = (jsval)pc2;
diff -r 1194/src/jsobj.c 1195/src/jsobj.c
3807c3807
<     jsval v;
---
>     jsval v, save;
3810c3810
<     v = OBJECT_TO_JSVAL(obj);
---
>     v = save = OBJECT_TO_JSVAL(obj);
3854c3854
<         str = js_DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, str);
---
>         str = js_DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, save, str);
Only in 1194/src: .#jsobj.c.3.287
diff -r 1194/src/jsopcode.c 1195/src/jsopcode.c
445c445
< #define QUOTE_IN_XML    0x10000
---
> #define DONT_ESCAPE     0x10000
450c450
<     JSBool inXML, ok;
---
>     JSBool dontEscape, ok;
457c457
<     inXML = (quote & QUOTE_IN_XML) != 0;
---
>     dontEscape = (quote & DONT_ESCAPE) != 0;
493c493
<             ok = inXML
---
>             ok = dontEscape
573d572
<     JSPackedBool    dvgflag;        /* js_DecompileValueGenerator magic flag */
574a574
>     jsbytecode      *dvgfence;      /* js_DecompileValueGenerator fencepost */
603d602
<     jp->dvgflag = JS_FALSE;
604a604
>     jp->dvgfence = NULL;
647a648
>     const char *bp;
655,660c656,661
<     JS_ASSERT(jp->sprinter.base[offset+0] == ' ');
<     JS_ASSERT(jp->sprinter.base[offset+1] == '{');
<     JS_ASSERT(!jp->pretty || jp->sprinter.base[offset+2] == '\n');
< 
<     jp->spaceOffset = offset;
<     jp->braceState = DONT_BRACE;
---
>     bp = jp->sprinter.base;
>     if (bp[offset+0] == ' ' && bp[offset+1] == '{') {
>         JS_ASSERT(!jp->pretty || bp[offset+2] == '\n');
>         jp->spaceOffset = offset;
>         jp->braceState = DONT_BRACE;
>     }
695,714c696,715
<                 JS_ASSERT(bp[offset+0] == ' ');
<                 JS_ASSERT(bp[offset+1] == '{');
<                 delta = 2;
<                 if (jp->pretty) {
<                     /* If pretty, we don't have to worry about 'else'. */
<                     JS_ASSERT(bp[offset+2] == '\n');
<                 } else if (bp[offset-1] != ')') {
<                     /* Must keep ' ' to avoid 'dolet' or 'elselet'. */
<                     ++offset;
<                     delta = 1;
<                 }
< 
<                 from = offset + delta;
<                 memmove(bp + offset, bp + from, jp->sprinter.offset - from);
<                 jp->sprinter.offset -= delta;
<                 jp->spaceOffset = -1;
< 
<                 format += 2;
<                 if (*format == '\0')
<                     return 0;
---
>                 if (bp[offset+0] == ' ' && bp[offset+1] == '{') {
>                     delta = 2;
>                     if (jp->pretty) {
>                         /* If pretty, we don't have to worry about 'else'. */
>                         JS_ASSERT(bp[offset+2] == '\n');
>                     } else if (bp[offset-1] != ')') {
>                         /* Must keep ' ' to avoid 'dolet' or 'elselet'. */
>                         ++offset;
>                         delta = 1;
>                     }
> 
>                     from = offset + delta;
>                     memmove(bp + offset, bp + from, jp->sprinter.offset - from);
>                     jp->sprinter.offset -= delta;
>                     jp->spaceOffset = -1;
> 
>                     format += 2;
>                     if (*format == '\0')
>                         return 0;
>                 }
769a771,823
> /*
>  * Get a stacked offset from ss->sprinter.base, or if the stacked value |off|
>  * is negative, lazily fetch the generating pc at |spindex = 1 + off| and try
>  * to decompile the code that generated the missing value.  This is used when
>  * reporting errors, where the model stack will lack |pcdepth| non-negative
>  * offsets (see js_DecompileValueGenerator and js_DecompileCode).
>  *
>  * If the stacked offset is -1, return 0 to index the NUL padding at the start
>  * of ss->sprinter.base.  If this happens, it means there is a decompiler bug
>  * to fix, but it won't violate memory safety.
>  */
> static ptrdiff_t
> GetOff(SprintStack *ss, uintN i)
> {
>     ptrdiff_t off;
>     JSString *str;
> 
>     off = ss->offsets[i];
>     if (off < 0) {
> #if defined DEBUG_brendan || defined DEBUG_mrbkap || defined DEBUG_crowder
>         JS_ASSERT(off < -1);
> #endif
>         if (++off == 0) {
>             if (!ss->sprinter.base && SprintPut(&ss->sprinter, "", 0) >= 0)
>                 memset(ss->sprinter.base, 0, ss->sprinter.offset);
>             return 0;
>         }
> 
>         str = js_DecompileValueGenerator(ss->sprinter.context, off,
>                                          JSVAL_NULL, NULL);
>         if (!str)
>             return 0;
>         off = SprintCString(&ss->sprinter, JS_GetStringBytes(str));
>         if (off < 0)
>             off = 0;
>         ss->offsets[i] = off;
>     }
>     return off;
> }
> 
> static const char *
> GetStr(SprintStack *ss, uintN i)
> {
>     ptrdiff_t off;
> 
>     /*
>      * Must call GetOff before using ss->sprinter.base, since it may be null
>      * until bootstrapped by GetOff.
>      */
>     off = GetOff(ss, i);
>     return OFF2STR(&ss->sprinter, off);
> }
> 
802a857
>     memset(OFF2STR(&ss->sprinter, ss->sprinter.offset), 0, PAREN_SLOP);
820a876
>     off = GetOff(ss, top);
824,827c880,881
<         ss->offsets[top] -= 2;
<         ss->sprinter.offset = ss->offsets[top];
<         off = Sprint(&ss->sprinter, "(%s)",
<                      OFF2STR(&ss->sprinter, ss->sprinter.offset + 2));
---
>         ss->sprinter.offset = ss->offsets[top] = off - 2;
>         off = Sprint(&ss->sprinter, "(%s)", OFF2STR(&ss->sprinter, off));
829c883
<         off = ss->sprinter.offset = ss->offsets[top];
---
>         ss->sprinter.offset = off;
833a888,896
> static const char *
> PopStr(SprintStack *ss, JSOp op)
> {
>     ptrdiff_t off;
> 
>     off = PopOff(ss, op);
>     return OFF2STR(&ss->sprinter, off);
> }
> 
875c938
<     off = isCondSwitch ? ss->offsets[ss->top-1] : PopOff(ss, JSOP_NOP);
---
>     off = isCondSwitch ? GetOff(ss, ss->top-1) : PopOff(ss, JSOP_NOP);
1021a1085,1144
> const char *
> GetLocal(SprintStack *ss, jsint i)
> {
>     ptrdiff_t off;
>     JSContext *cx;
>     JSScript *script;
>     jsatomid j, n;
>     JSAtom *atom;
>     JSObject *obj;
>     jsint depth, count;
>     JSScopeProperty *sprop;
>     const char *rval;
> 
> #define LOCAL_ASSERT(expr)      JS_BEGIN_MACRO                                \
>                                     JS_ASSERT(expr);                          \
>                                     if (!(expr)) return NULL;                 \
>                                 JS_END_MACRO
> 
>     off = ss->offsets[i];
>     if (off >= 0)
>         return OFF2STR(&ss->sprinter, off);
> 
>     /*
>      * We must be called from js_DecompileValueGenerator (via Decompile) when
>      * dereferencing a local that's undefined or null.  Search script->atomMap
>      * for the block containing this local by its stack index, i.
>      */
>     cx = ss->sprinter.context;
>     script = ss->printer->script;
>     for (j = 0, n = script->atomMap.length; j < n; j++) {
>         atom = script->atomMap.vector[j];
>         if (ATOM_IS_OBJECT(atom)) {
>             obj = ATOM_TO_OBJECT(atom);
>             if (OBJ_GET_CLASS(cx, obj) == &js_BlockClass) {
>                 depth = OBJ_BLOCK_DEPTH(cx, obj);
>                 count = OBJ_BLOCK_COUNT(cx, obj);
>                 if ((jsuint)(i - depth) < (jsuint)count)
>                     break;
>             }
>         }
>     }
> 
>     LOCAL_ASSERT(j < n);
>     i -= depth;
>     for (sprop = OBJ_SCOPE(obj)->lastProp; sprop; sprop = sprop->parent) {
>         if (sprop->shortid == i)
>             break;
>     }
> 
>     LOCAL_ASSERT(sprop && JSID_IS_ATOM(sprop->id));
>     atom = JSID_TO_ATOM(sprop->id);
>     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
>     if (!rval)
>         return NULL;
>     RETRACT(&ss->sprinter, rval);
>     return rval;
> 
> #undef LOCAL_ASSERT
> }
> 
1027c1150
<     jsbytecode *endpc, *pc2, *done, *forelem_tail, *forelem_done;
---
>     jsbytecode *startpc, *endpc, *pc2, *done, *forelem_tail, *forelem_done;
1066c1189
< #define POP_STR()               OFF2STR(&ss->sprinter, PopOff(ss, op))
---
> #define POP_STR()               PopStr(ss, op)
1114a1238
>     startpc = pc;
1139c1263,1264
<         if (jp->dvgflag && pc + oplen == endpc) {
---
>         if (pc + oplen == jp->dvgfence) {
>             JSStackFrame *fp;
1141a1267,1273
>             /*
>              * Rewrite non-get ops to their "get" format if the error is in
>              * the bytecode at pc, so we don't decompile more than the error
>              * expression.
>              */
>             for (fp = cx->fp; fp && !fp->script; fp = fp->down)
>                 continue;
1143c1275,1277
<             if (format & (JOF_SET|JOF_DEL|JOF_INCDEC|JOF_IMPORT|JOF_FOR)) {
---
>             if (((fp && pc == fp->pc) ||
>                  (pc == startpc && cs->nuses != 0)) &&
>                 format & (JOF_SET|JOF_DEL|JOF_INCDEC|JOF_IMPORT|JOF_FOR)) {
1159a1294,1297
> 
>                     i = cs->nuses - js_CodeSpec[op].nuses;
>                     while (--i >= 0)
>                         PopOff(ss, JSOP_NOP);
1189c1327
<                             JS_ASSERT(0);
---
>                             LOCAL_ASSERT(0);
1207c1345
<             JS_ASSERT(js_CodeSpec[saveop].length == oplen);
---
>             LOCAL_ASSERT(js_CodeSpec[saveop].length == oplen);
1209c1347
<             jp->dvgflag = JS_FALSE;
---
>             jp->dvgfence = NULL;
1223c1361
<                     JS_ASSERT(op != saveop);
---
>                     LOCAL_ASSERT(op != saveop);
1236c1374
<                     JS_ASSERT(op == JSOP_ADD);
---
>                     LOCAL_ASSERT(op == JSOP_ADD);
1330c1468
<                     js_printf(jp, "\t%s:\n", rval);
---
>                     js_printf(CLEAR_MAYBE_BRACE(jp), "\t%s:\n", rval);
1353c1491
<                     JS_ASSERT(ATOM_IS_OBJECT(atom));
---
>                     LOCAL_ASSERT(ATOM_IS_OBJECT(atom));
1581c1719
<                         JS_ASSERT(pc[len] == JSOP_LEAVEBLOCKEXPR);
---
>                         LOCAL_ASSERT(pc[len] == JSOP_LEAVEBLOCKEXPR);
1649c1787
<                     JS_ASSERT(!strcmp(rval, iter_cookie));
---
>                     LOCAL_ASSERT(!strcmp(rval, iter_cookie));
1654c1792
<                 JS_ASSERT(!js_GetSrcNote(jp->script, pc));
---
>                 LOCAL_ASSERT(!js_GetSrcNote(jp->script, pc));
1677d1814
<                 atom = GET_ATOM(cx, jp->script, pc);
1693c1830
<                     JS_ASSERT(sprop->shortid < argc);
---
>                     LOCAL_ASSERT(sprop->shortid < argc);
1733,1735c1870,1872
<                     str = ATOM_TO_STRING(atomv[i - OBJ_BLOCK_DEPTH(cx, obj)]);
<                     rval = QuoteString(&ss->sprinter, str, 0);
<                     if (!rval) {
---
>                     atom = atomv[i - OBJ_BLOCK_DEPTH(cx, obj)];
>                     str = ATOM_TO_STRING(atom);
>                     if (!QuoteString(&jp->sprinter, str, 0)) {
1739,1740d1875
<                     RETRACT(&ss->sprinter, rval);
<                     js_printf(jp, "%s", rval);
1745c1880
<                         JS_ASSERT(len > 0);
---
>                         LOCAL_ASSERT(len > 0);
1779,1780c1914,1918
<                 if (sn) {
<                     JS_ASSERT(op == JSOP_LEAVEBLOCK);
---
>                 if (op == JSOP_LEAVEBLOCKEXPR) {
>                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_PCBASE);
>                     rval = POP_STR();
>                 } else if (sn) {
>                     LOCAL_ASSERT(op == JSOP_LEAVEBLOCK);
1786,1787d1923
<                 if (op == JSOP_LEAVEBLOCKEXPR)
<                     rval = POP_STR();
1790c1926
<                 JS_ASSERT(top >= depth);
---
>                 LOCAL_ASSERT(top >= depth);
1793c1929
<                 ss->sprinter.offset = ss->offsets[top];
---
>                 ss->sprinter.offset = GetOff(ss, top);
1802,1844c1938,1939
<                 if ((uintN)i < ss->top) {
<                     rval = OFF2STR(&ss->sprinter, ss->offsets[i]);
<                 } else {
<                     jsatomid j, n;
<                     JSScript *script;
<                     jsint depth, count;
<                     JSScopeProperty *sprop;
< 
<                     /*
<                      * We must be called from js_DecompileValueGenerator when
<                      * dereferencing a local that's undefined or null.  Search
<                      * jp->script->atomMap for the block containing this local
<                      * by its stack index, i.
<                      */
<                     script = jp->script;
<                     for (j = 0, n = script->atomMap.length; j < n; j++) {
<                         atom = script->atomMap.vector[j];
<                         if (ATOM_IS_OBJECT(atom)) {
<                             obj = ATOM_TO_OBJECT(atom);
<                             if (OBJ_GET_CLASS(cx, obj) == &js_BlockClass) {
<                                 depth = OBJ_BLOCK_DEPTH(cx, obj);
<                                 count = OBJ_BLOCK_COUNT(cx, obj);
<                                 if ((jsuint)(i - depth) < (jsuint)count)
<                                     break;
<                             }
<                         }
<                     }
< 
<                     LOCAL_ASSERT(j < n);
<                     i -= depth;
<                     for (sprop = OBJ_SCOPE(obj)->lastProp; sprop;
<                          sprop = sprop->parent) {
<                         if (sprop->shortid == i)
<                             break;
<                     }
< 
<                     LOCAL_ASSERT(sprop && JSID_IS_ATOM(sprop->id));
<                     atom = JSID_TO_ATOM(sprop->id);
<                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
<                     if (!rval)
<                         return JS_FALSE;
<                     RETRACT(&ss->sprinter, rval);
<                 }
---
>                 LOCAL_ASSERT((uintN)i < ss->top);
>                 rval = GetLocal(ss, i);
1848a1944
>               case JSOP_SETLOCALPOP:
1850c1946
<                 lval = OFF2STR(&ss->sprinter, ss->offsets[i]);
---
>                 lval = GetStr(ss, i);
1857c1953
<                 lval = OFF2STR(&ss->sprinter, ss->offsets[i]);
---
>                 lval = GetLocal(ss, i);
1863c1959
<                 lval = OFF2STR(&ss->sprinter, ss->offsets[i]);
---
>                 lval = GetLocal(ss, i);
1868c1964
<                 lval = OFF2STR(&ss->sprinter, ss->offsets[i]);
---
>                 lval = GetStr(ss, i);
2206c2302
<                     JS_ASSERT(*xval != '\0');
---
>                     LOCAL_ASSERT(*xval != '\0');
2221c2317
<                 rval = OFF2STR(&ss->sprinter, ss->offsets[ss->top-1]);
---
>                 rval = GetStr(ss, ss->top-1);
2289c2385,2391
<                 LOCAL_ASSERT(strcmp(rval, forelem_cookie) == 0);
---
>                 if (strcmp(rval, forelem_cookie) != 0) {
>                     if (strcmp(lval, "()") == 0)
>                         lval = "";
>                     js_printf(jp, "\t%s[%s] = %s\n", lval, xval, rval);
>                     todo = -2;
>                     break;
>                 }
2306c2408
<                 rval = OFF2STR(&ss->sprinter, ss->offsets[ss->top-2]);
---
>                 rval = GetStr(ss, ss->top-2);
2313c2415
<                 rval = OFF2STR(&ss->sprinter, ss->offsets[ss->top-1]);
---
>                 rval = GetStr(ss, ss->top-1);
2359a2462,2469
>                 if (op == JSOP_SETLOCALPOP) {
>                     if (!PushOff(ss, todo, saveop))
>                         return JS_FALSE;
>                     rval = POP_STR();
>                     LOCAL_ASSERT(*rval != '\0');
>                     js_printf(jp, "\t%s;\n", rval);
>                     todo = -2;
>                 }
2526c2636
<                 op = saveop;
---
>                 op = JSOP_GETELEM;
2587c2697
<                 op = saveop;
---
>                 op = JSOP_GETELEM;
2806c2916
<                   default:                JS_ASSERT(0);
---
>                   default:                LOCAL_ASSERT(0);
2830c2940
<                                    inXML ? QUOTE_IN_XML : '"');
---
>                                    inXML ? DONT_ESCAPE : '"');
2873c2983
<                 JS_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
---
>                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
2900c3010
<                                 JS_ASSERT(SN_TYPE(sn) == SRC_LABEL);
---
>                                 LOCAL_ASSERT(SN_TYPE(sn) == SRC_LABEL);
2934c3044
<                 JS_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
---
>                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
2951c3061
<                         JS_ASSERT(SN_TYPE(sn) == SRC_LABEL);
---
>                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_LABEL);
2982c3092
<                 JS_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
---
>                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
2994,2995c3104,3105
<                     JS_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT ||
<                               *pc2 == JSOP_CASEX || *pc2 == JSOP_DEFAULTX);
---
>                     LOCAL_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT ||
>                                  *pc2 == JSOP_CASEX || *pc2 == JSOP_DEFAULTX);
3001c3111
<                         JS_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
---
>                         LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
3019,3020c3129,3130
<                     JS_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT ||
<                               *pc2 == JSOP_CASEX || *pc2 == JSOP_DEFAULTX);
---
>                     LOCAL_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT ||
>                                  *pc2 == JSOP_CASEX || *pc2 == JSOP_DEFAULTX);
3026c3136
<                         JS_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
---
>                         LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
3069c3179
<                 JS_ASSERT(ATOM_IS_OBJECT(atom));
---
>                 LOCAL_ASSERT(ATOM_IS_OBJECT(atom));
3190,3191c3300,3301
<                     JS_ASSERT(strncmp(rval, js_function_str, 8) == 0 &&
<                               rval[8] == ' ');
---
>                     LOCAL_ASSERT(strncmp(rval, js_function_str, 8) == 0 &&
>                                  rval[8] == ' ');
3193c3303
<                     JS_ASSERT(rval[strlen(rval)-1] == '}');
---
>                     LOCAL_ASSERT(rval[strlen(rval)-1] == '}');
3373d3482
<                 atom = GET_ATOM(cx, jp->script, pc);
3448c3557,3558
< js_DecompileCode(JSPrinter *jp, JSScript *script, jsbytecode *pc, uintN len)
---
> js_DecompileCode(JSPrinter *jp, JSScript *script, jsbytecode *pc, uintN len,
>                  uintN pcdepth)
3449a3560
>     uintN depth, i;
3457a3569,3571
>     depth = script->depth;
>     JS_ASSERT(pcdepth <= depth);
> 
3465,3466c3579,3580
<     offsetsz = script->depth * sizeof(ptrdiff_t);
<     opcodesz = script->depth * sizeof(jsbytecode);
---
>     offsetsz = depth * sizeof(ptrdiff_t);
>     opcodesz = depth * sizeof(jsbytecode);
3474c3588,3627
<     ss.top = ss.inArrayInit = 0;
---
>     ss.top = pcdepth;
>     ss.inArrayInit = 0;
> 
>     /*
>      * If we are called from js_DecompileValueGenerator with a portion of
>      * script's bytecode that starts with a non-zero model stack depth given
>      * by pcdepth, attempt to initialize the missing string offsets in ss to
>      * |spindex| negative indexes from fp->sp for the activation fp in which
>      * the error arose.
>      *
>      * See js_DecompileValueGenerator for how its |spindex| parameter is used,
>      * and see also GetOff, which makes use of the ss.offsets[i] < -1 that are
>      * potentially stored below.
>      */
>     if (pcdepth != 0) {
>         JSStackFrame *fp;
>         ptrdiff_t top;
> 
>         for (fp = cx->fp; fp && !fp->script; fp = fp->down)
>             continue;
>         top = fp ? fp->sp - fp->spbase : 0;
>         for (i = 0; i < pcdepth; i++) {
>             ss.offsets[i] = -1;
>             ss.opcodes[i] = JSOP_NOP;
>         }
>         if (fp && fp->pc == pc) {
>             JS_ASSERT((uintN)top == pcdepth);
>             for (i = 0; i < pcdepth; i++) {
>                 ptrdiff_t off;
>                 jsbytecode *genpc;
> 
>                 off = (intN)i - (intN)depth;
>                 genpc = (jsbytecode *) fp->spbase[off];
>                 if (JS_UPTRDIFF(genpc, script->code) < script->length) {
>                     ss.offsets[i] += (ptrdiff_t)i - top;
>                     ss.opcodes[i] = *genpc;
>                 }
>             }
>         }
>     }
3485,3486c3638,3639
<             last = OFF2STR(&ss.sprinter, PopOff(&ss, JSOP_NOP));
<         } while (ss.top);
---
>             last = OFF2STR(&ss.sprinter, PopOff(&ss, JSOP_POP));
>         } while (ss.top > pcdepth);
3499c3652
<     return js_DecompileCode(jp, script, script->code, (uintN)script->length);
---
>     return js_DecompileCode(jp, script, script->code, (uintN)script->length, 0);
3519c3672
<     ok = js_DecompileCode(jp, script, script->code, (uintN)script->length);
---
>     ok = js_DecompileCode(jp, script, script->code, (uintN)script->length, 0);
3532a3686,3687
>     jsbytecode *pc;
>     ptrdiff_t len;
3587a3743
>         pc = fun->u.i.script->main;
3590a3747,3757
> 
> #if JS_HAS_DESTRUCTURING
>             if (!params[i]) {
>                 JS_ASSERT(*pc == JSOP_GETARG);
>                 pc += JSOP_GETARG_LENGTH;
>                 JS_ASSERT(*pc == JSOP_DUP);
>                 /* FIXME: bug 346642 */
>                 continue;
>             }
> #endif
> 
3597a3765
>         pc = NULL;
3607c3775,3776
<         ok = js_DecompileScript(jp, fun->u.i.script);
---
>         len = fun->u.i.script->code + fun->u.i.script->length - pc;
>         ok = js_DecompileCode(jp, fun->u.i.script, pc, (uintN)len, 0);
3632c3801,3802
<     jsval *sp, *base, *limit;
---
>     jsval *sp, *spbase, *base, *limit;
>     intN depth, pcdepth;
3636d3805
<     intN depth;
3638c3807
<     uintN len;
---
>     ptrdiff_t len, oplen;
3648a3818,3828
>     sp = fp->sp;
>     spbase = fp->spbase;
>     if ((uintN)(sp - spbase) > fp->script->depth) {
>         /*
>          * Preparing to make an internal invocation, using an argv stack
>          * segment pushed just above fp's operand stack space.  Such an argv
>          * stack has no generating pc "basement", so we must fall back.
>          */
>         goto do_fallback;
>     }
> 
3660a3841
>             spbase = down->spbase;
3671c3852
<             base = fp->spbase;
---
>             spbase = base = fp->spbase;
3698c3879,3881
<         for (sp = limit; sp > base; ) {
---
>         for (sp = limit;;) {
>             if (sp <= base)
>                 goto do_fallback;
3702c3885,3886
<                 pc = (jsbytecode *) sp[-depth];
---
>                 sp -= depth;
>                 pc = (jsbytecode *) *sp;
3736c3920
<      * from sp[-(1+depth)].
---
>      * from fp->sp[-(1+depth)].
3747,3749c3931,3950
<     /* XXX handle null as a special case, to avoid calling null "object" */
<     if (op == JSOP_NULL)
<         return ATOM_TO_STRING(cx->runtime->atomState.nullAtom);
---
>     /* None of these stack-writing ops generates novel values. */
>     JS_ASSERT(op != JSOP_CASE && op != JSOP_CASEX &&
>               op != JSOP_DUP && op != JSOP_DUP2 &&
>               op != JSOP_SWAP);
> 
>     /*
>      * |this| could convert to a very long object initialiser, so cite it by
>      * its keyword name instead.
>      */
>     if (op == JSOP_THIS)
>         return JS_NewStringCopyZ(cx, js_this_str);
> 
>     /*
>      * JSOP_BINDNAME is special: it generates a value, the base object of a
>      * reference.  But if it is the generating op for a diagnostic produced by
>      * js_DecompileValueGenerator, the name being bound is irrelevant.  Just
>      * fall back to the base object.
>      */
>     if (op == JSOP_BINDNAME)
>         goto do_fallback;
3751c3952
<     /* NAME ops are self-contained, but others require left context. */
---
>     /* NAME ops are self-contained, others require left or right context. */
3753,3755c3954,3958
<     if ((cs->format & JOF_MODEMASK) == JOF_NAME) {
<         begin = pc;
<     } else {
---
>     begin = pc;
>     end = pc + cs->length;
>     if ((cs->format & JOF_MODEMASK) != JOF_NAME) {
>         JSSrcNoteType noteType;
> 
3757,3759c3960,3968
<         if (!sn || (SN_TYPE(sn) != SRC_PCBASE && SN_TYPE(sn) != SRC_PCDELTA)) {
<             if (cs->token)
<                 return JS_NewStringCopyZ(cx, cs->token);
---
>         if (!sn)
>             goto do_fallback;
>         noteType = SN_TYPE(sn);
>         if (noteType == SRC_PCBASE) {
>             begin -= js_GetSrcNoteOffset(sn, 0);
>         } else if (noteType == SRC_PCDELTA) {
>             end = begin + js_GetSrcNoteOffset(sn, 0);
>             begin += cs->length;
>         } else {
3762d3970
<         begin = pc - js_GetSrcNoteOffset(sn, 0);
3764d3971
<     end = pc + cs->length;
3765a3973,4120
>     if (len <= 0)
>         goto do_fallback;
> 
>     /*
>      * Walk forward from script->main and compute starting stack depth.
>      * FIXME: Code to compute oplen copied from js_Disassemble1 and reduced.
>      * FIXME: Optimize to use last empty-stack sequence point.
>      */
>     pcdepth = 0;
>     for (pc = script->main; pc < begin; pc += oplen) {
>         jsbytecode *pc2;
>         uint32 type;
>         intN nuses, ndefs;
> 
>         /* Let pc2 be non-null only for JSOP_LITOPX. */
>         pc2 = NULL;
>         op = (JSOp) *pc;
>         cs = &js_CodeSpec[op];
>         oplen = cs->length;
> 
>         if (op == JSOP_SETSP) {
>             pcdepth = GET_UINT16(pc);
>             continue;
>         }
> 
>         /*
>          * A (C ? T : E) expression requires skipping either T (if begin is in
>          * E) or both T and E (if begin is after the whole expression) before
>          * adjusting pcdepth based on the JSOP_IFEQ or JSOP_IFEQX at pc that
>          * tests condition C.  We know that the stack depth can't change from
>          * what it was with C on top of stack.
>          */
>         sn = js_GetSrcNote(script, pc);
>         if (sn && SN_TYPE(sn) == SRC_COND) {
>             ptrdiff_t jmpoff, jmplen;
> 
>             jmpoff = js_GetSrcNoteOffset(sn, 0);
>             if (pc + jmpoff < begin) {
>                 pc += jmpoff;
>                 op = *pc;
>                 JS_ASSERT(op == JSOP_GOTO || op == JSOP_GOTOX);
>                 cs = &js_CodeSpec[op];
>                 oplen = cs->length;
>                 jmplen = GetJumpOffset(pc, pc);
>                 if (pc + jmplen < begin) {
>                     oplen = (uintN) jmplen;
>                     continue;
>                 }
> 
>                 /*
>                  * Ok, begin lies in E.  Manually pop C off the model stack,
>                  * since we have moved beyond the IFEQ now.
>                  */
>                 --pcdepth;
>             }
>         }
> 
>         type = cs->format & JOF_TYPEMASK;
>         switch (type) {
>           case JOF_TABLESWITCH:
>           case JOF_TABLESWITCHX:
>           {
>             jsint jmplen, i, low, high;
> 
>             jmplen = (type == JOF_TABLESWITCH) ? JUMP_OFFSET_LEN
>                                                : JUMPX_OFFSET_LEN;
>             pc2 = pc;
>             pc2 += jmplen;
>             low = GET_JUMP_OFFSET(pc2);
>             pc2 += JUMP_OFFSET_LEN;
>             high = GET_JUMP_OFFSET(pc2);
>             pc2 += JUMP_OFFSET_LEN;
>             for (i = low; i <= high; i++)
>                 pc2 += jmplen;
>             oplen = 1 + pc2 - pc;
>             break;
>           }
> 
>           case JOF_LOOKUPSWITCH:
>           case JOF_LOOKUPSWITCHX:
>           {
>             jsint jmplen;
>             jsbytecode *pc2;
>             jsatomid npairs;
> 
>             jmplen = (type == JOF_LOOKUPSWITCH) ? JUMP_OFFSET_LEN
>                                                 : JUMPX_OFFSET_LEN;
>             pc2 = pc;
>             pc2 += jmplen;
>             npairs = GET_ATOM_INDEX(pc2);
>             pc2 += ATOM_INDEX_LEN;
>             while (npairs) {
>                 pc2 += ATOM_INDEX_LEN;
>                 pc2 += jmplen;
>                 npairs--;
>             }
>             oplen = 1 + pc2 - pc;
>             break;
>           }
> 
>           case JOF_LITOPX:
>             pc2 = pc + 1 + LITERAL_INDEX_LEN;
>             op = *pc2;
>             cs = &js_CodeSpec[op];
>             JS_ASSERT(cs->length > ATOM_INDEX_LEN);
>             oplen += cs->length - (1 + ATOM_INDEX_LEN);
>             break;
> 
>           default:;
>         }
> 
>         if (sn && SN_TYPE(sn) == SRC_HIDDEN)
>             continue;
> 
>         nuses = cs->nuses;
>         if (nuses < 0) {
>             /* Call opcode pushes [callee, this, argv...]. */
>             nuses = 2 + GET_ARGC(pc);
>         } else if (op == JSOP_RETSUB) {
>             /* Pop [exception or hole, retsub pc-index]. */
>             JS_ASSERT(nuses == 0);
>             nuses = 2;
>         } else if (op == JSOP_LEAVEBLOCK || op == JSOP_LEAVEBLOCKEXPR) {
>             JS_ASSERT(nuses == 0);
>             nuses = GET_UINT16(pc);
>         }
>         pcdepth -= nuses;
>         JS_ASSERT(pcdepth >= 0);
> 
>         ndefs = cs->ndefs;
>         if (op == JSOP_FINALLY) {
>             /* Push [exception or hole, retsub pc-index]. */
>             JS_ASSERT(ndefs == 0);
>             ndefs = 2;
>         } else if (op == JSOP_ENTERBLOCK) {
>             jsatomid atomIndex;
>             JSAtom *atom;
>             JSObject *obj;
> 
>             JS_ASSERT(ndefs == 0);
>             atomIndex = pc2 ? GET_LITERAL_INDEX(pc) : GET_ATOM_INDEX(pc);
>             atom = js_GetAtom(cx, &script->atomMap, atomIndex);
>             obj = ATOM_TO_OBJECT(atom);
>             JS_ASSERT(OBJ_BLOCK_DEPTH(cx, obj) == pcdepth);
>             ndefs = OBJ_BLOCK_COUNT(cx, obj);
>         }
>         pcdepth += ndefs;
>     }
3774,3775c4129,4130
<         jp->dvgflag = JS_TRUE;
<         if (js_DecompileCode(jp, script, begin, len))
---
>         jp->dvgfence = end;
>         if (js_DecompileCode(jp, script, begin, (uintN)len, (uintN)pcdepth))
diff -r 1194/src/jsopcode.h 1195/src/jsopcode.h
287c287,288
< js_DecompileCode(JSPrinter *jp, JSScript *script, jsbytecode *pc, uintN len);
---
> js_DecompileCode(JSPrinter *jp, JSScript *script, jsbytecode *pc, uintN len,
>                  uintN pcdepth);
diff -r 1194/src/jsopcode.tbl 1195/src/jsopcode.tbl
324d323
<  * XXX JSOP_SWAP doesn't swap the corresponding pc stack generating pcs.
diff -r 1194/src/jsparse.c 1195/src/jsparse.c
248d247
< #if JS_HAS_XML_SUPPORT
250c249
< #endif
---
>     pn->pn_source = NULL;
325d323
< #if JS_HAS_XML_SUPPORT
327c325
< #endif
---
>     pn->pn_source = NULL;
855c853
<  * of CheckDestructuring and its subroutines.
---
>  * of CheckDestructuring and its friends.
987,990c985,987
< static JSBool
< CheckDestructuring(JSContext *cx, BindData *data,
<                    JSParseNode *left, JSParseNode *right,
<                    JSTreeContext *tc);
---
> static JSParseNode *
> DestructuringExpr(JSContext *cx, BindData *data, JSTreeContext *tc,
>                   JSTokenType tt);
1200c1197
<     /* Initialize early for possible flags mutation via CheckDestructuring. */
---
>     /* Initialize early for possible flags mutation via DestructuringExpr. */
1225,1228d1221
<                 lhs = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
<                 if (!lhs)
<                     return NULL;
< 
1242c1235,1236
<                 if (!CheckDestructuring(cx, &data, lhs, NULL, &funtc))
---
>                 lhs = DestructuringExpr(cx, &data, &funtc, tt);
>                 if (!lhs)
2144c2138,2139
<             if (pn->pn_type != TOK_COMMA) {
---
>             /* Nullary comma is an elision; binary comma is an expression.*/
>             if (pn->pn_type != TOK_COMMA || pn->pn_arity != PN_NULLARY) {
2222a2218,2231
> static JSParseNode *
> DestructuringExpr(JSContext *cx, BindData *data, JSTreeContext *tc,
>                   JSTokenType tt)
> {
>     JSParseNode *pn;
> 
>     pn = PrimaryExpr(cx, data->ts, tc, tt, JS_FALSE);
>     if (!pn)
>         return NULL;
>     if (!CheckDestructuring(cx, data, pn, NULL, tc))
>         return NULL;
>     return pn;
> }
> 
2347,2362d2355
< #if JS_HAS_BLOCK_SCOPE
< static JSStmtInfo *
< FindMaybeScopeStatement(JSTreeContext *tc)
< {
<     JSStmtInfo *stmt;
< 
<     stmt = tc->topStmt;
<     while (stmt) {
<         if (STMT_MAYBE_SCOPE(stmt))
<             return stmt;
<         stmt = stmt->down;
<     }
<     return NULL;
< }
< #endif
< 
2553a2547
>         ts->flags |= TSF_OPERAND;
2554a2549
>             ts->flags &= ~TSF_OPERAND;
2560a2556
>             ts->flags &= ~TSF_OPERAND;
3059c3055
<                     pn3 = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
---
>                     pn3 = DestructuringExpr(cx, &data, tc, tt);
3062,3064d3057
< 
<                     if (!CheckDestructuring(cx, &data, pn3, NULL, tc))
<                         return NULL;
3114c3107,3110
<             } while ((tt = js_GetToken(cx, ts)) == TOK_CATCH);
---
>                 ts->flags |= TSF_OPERAND;
>                 tt = js_GetToken(cx, ts);
>                 ts->flags &= ~TSF_OPERAND;
>             } while (tt == TOK_CATCH);
3291a3288
>         JSStmtInfo **sip;
3309,3313c3306,3311
<          * to be our scope statement. Further let declarations in this block
<          * will find this scope statement and use the same block object. If we
<          * are the first let declaration in this block (i.e., when the nearest
<          * maybe-scope JSStmtInfo isn't a scope statement) then we also need
<          * to set tc->blockNode to be our TOK_LEXICALSCOPE.
---
>          * that is a block or a switch body to be our scope statement. Further
>          * let declarations in this block will find this scope statement and
>          * use the same block object. If we are the first let declaration in
>          * this block (i.e., when the nearest maybe-scope JSStmtInfo isn't a
>          * scope statement) then we also need to set tc->blockNode to be our
>          * TOK_LEXICALSCOPE.
3315c3313,3320
<         stmt = FindMaybeScopeStatement(tc);
---
>         sip = &tc->topScopeStmt;
>         for (stmt = tc->topStmt; stmt; stmt = stmt->down) {
>             if (STMT_MAYBE_SCOPE(stmt))
>                 break;
>             if (stmt == *sip)
>                 sip = &stmt->downScope;
>         }
> 
3348a3354,3359
>             /*
>              * Insert stmt on the tc->topScopeStmt/stmtInfo.downScope linked
>              * list stack, if it isn't already there.  If it is there, but it
>              * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
>              * block.
>              */
3351,3353c3362,3369
<             if (!stmt->downScope) {
<                 stmt->downScope = tc->topScopeStmt;
<                 tc->topScopeStmt = stmt;
---
>             if (stmt != *sip) {
>                 JS_ASSERT(!stmt->downScope);
>                 JS_ASSERT(stmt->type == STMT_BLOCK ||
>                           stmt->type == STMT_SWITCH ||
>                           stmt->type == STMT_TRY ||
>                           stmt->type == STMT_FINALLY);
>                 stmt->downScope = *sip;
>                 *sip = stmt;
3355c3371,3372
<                 JS_ASSERT(stmt == tc->topScopeStmt);
---
>                 JS_ASSERT(stmt->type == STMT_CATCH);
>                 JS_ASSERT(stmt->downScope);
3356a3374
> 
3527a3546
>         ts->flags |= TSF_OPERAND;
3528a3548
>         ts->flags &= ~TSF_OPERAND;
3575c3595
<     data.op = CURRENT_TOKEN(ts).t_op;
---
>     data.op = let ? JSOP_NOP : CURRENT_TOKEN(ts).t_op;
3580c3600
<     pn->pn_op = let ? JSOP_NOP : data.op;
---
>     pn->pn_op = data.op;
4162a4183
>             ts->flags |= TSF_OPERAND;
4163a4185
>             ts->flags &= ~TSF_OPERAND;
4263d4284
< #if JS_HAS_XML_SUPPORT
4265c4286
< #endif
---
>             pn2->pn_source = NULL;
5101d5121
<     JSBool afterComma;
5316c5336
<                         pnlet = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
---
>                         pnlet = DestructuringExpr(cx, &data, tc, tt);
5320,5322d5339
<                         if (!CheckDestructuring(cx, &data, pnlet, NULL, tc))
<                             return NULL;
< 
5410a5428,5430
>       {
>         JSBool afterComma;
> 
5526a5547
>       }
diff -r 1194/src/jsparse.h 1195/src/jsparse.h
318,320c318,319
< #if JS_HAS_XML_SUPPORT
<     JSTokenStream       *pn_ts;         /* token stream for XML error reports */
< #endif
---
>     JSTokenStream       *pn_ts;         /* token stream for error reports */
>     JSAtom              *pn_source;     /* saved source for decompilation */
diff -r 1194/src/jsscan.c 1195/src/jsscan.c
193,195c193,199
<         tbsize = (length + 1) * sizeof(jschar);
<         length += length + 1;
<         JS_ARENA_GROW_CAST(base, jschar *, pool, tbsize, tbsize);
---
>         if ((size_t)length >= ~(size_t)0 / sizeof(jschar)) {
>             base = NULL;
>         } else {
>             tbsize = (length + 1) * sizeof(jschar);
>             length += length + 1;
>             JS_ARENA_GROW_CAST(base, jschar *, pool, tbsize, tbsize);
>         }
533d536
< #if JS_HAS_XML_SUPPORT
535d537
< #endif
563d564
< #if JS_HAS_XML_SUPPORT
568d568
< #endif
582d581
< #if JS_HAS_XML_SUPPORT
588d586
< #endif
599d596
< #if JS_HAS_XML_SUPPORT
602c599
< #endif
---
> 
610c607
<                  */ 
---
>                  */
632,633c629,630
<              * If we can't find out where the error was based on the current frame,
<              * see if the next frame has a script/pc combo we can use.
---
>              * If we can't find out where the error was based on the current
>              * frame, see if the next frame has a script/pc combo we can use.
diff -r 1194/src/jsscript.c 1195/src/jsscript.c
1430,1431c1430,1435
<     if (*pc == JSOP_DEFFUN) {
<         atom = GET_ATOM(cx, script, pc);
---
>     if (*pc == JSOP_DEFFUN ||
>         (*pc == JSOP_LITOPX && pc[1 + LITERAL_INDEX_LEN] == JSOP_DEFFUN)) {
>         atom = js_GetAtom(cx, &script->atomMap,
>                           (*pc == JSOP_DEFFUN)
>                           ? GET_ATOM_INDEX(pc)
>                           : GET_LITERAL_INDEX(pc));
